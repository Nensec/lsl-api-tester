<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>V's Tester | Test Builder</title>

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        body {
            background-color: #121212;
        }

        .sidebar {
            height: 100vh;
            overflow-y: auto;
            border-right: 1px solid #444;
            background: #212529;
        }

        .main-content {
            height: 100vh;
            overflow-y: auto;
            padding: 20px;
        }

        .action-card {
            border-left: 4px solid #0d6efd;
            margin-bottom: 10px;
            background-color: #1f2d46;
        }

        .action-card.common-ref {
            border-left-color: #198754;
            background-color: #1e2b22;
        }

        .nested-actions {
            margin-left: 20px;
            border-left: 2px dashed #444;
            padding-left: 10px;
        }

        .btn-xs {
            padding: 0.25rem 0.5rem;
            font-size: 0.75rem;
        }

        .infoBubble {
            font-size: 0.8rem;
            opacity: 0.8;
            transition: opacity 0.2s;
        }

        .infoBubble.infoBubbleLarge {
            font-size: 1.2rem;
        }

        .infoBubble:hover {
            opacity: 1;
        }

        .tooltip {
            --bs-tooltip-max-width: 600px;
        }

        .tooltip-inner {
            text-align: left;
        }

        option:disabled {
            color: #7c7c7c;
        }

        .json-key {
            color: #f87171;
        }

        /* Red-ish */
        .json-string {
            color: #a3e635;
        }

        /* Green-ish */
        .json-number {
            color: #60a5fa;
        }

        /* Blue-ish */
        .json-boolean {
            color: #fbbf24;
        }

        /* Yellow */
        .json-null {
            color: #9ca3af;
            font-style: italic;
        }

        /* Gray */
        .json-container {
            background: #1a1d20;
            padding: 15px;
            border-radius: 5px;
            max-height: 60vh;
            overflow-y: auto;
        }
    </style>
</head>

<body>

    <div id="root"></div>

    <script type="text/babel">

        const { useState, useEffect, useMemo } = React;

        // -- CONSTANTS & DEFINITIONS

        const ACTION_TYPES = {
            0: { name: "SEND", params: [{ name: "target", description: "The target UUID to send the message to. If using a placeholder must resolve to a UUID." }, { name: "channel", description: "The channel to send the message on. If using a placeholder must resolve to a integer." }, { name: "message", description: "The message to send. You can use multiple placeholders to format your message." }] },
            1: { name: "ASK", params: [{ name: "message", description: "The question to ask the user. You can use multiple placeholders to format your question." }] },
            2: { name: "REZ", params: [{ name: "name", description: "The name to give the rezzed dummy. Can use multiple placeholders if you so wish." }, { name: "distance", description: "How far should the dummy be rezzed from you. Note: there is a 10m max range imposed by SL." }] },
            3: { name: "EXPECT", params: [{ name: "channel", description: "What channel should be monitored. If using a placeholder must resolve to a integer." }, { name: "value", description: "What message are we looking for? You can use an * to denote a wildcard, comparisons will only be done up to that point. Can use multiple placeholders." }, { name: "time", description: "What is the maximum time to wait for in milliseconds for the message to arrive? If using a placeholder must resolve to an integer." }, { name: "type", description: "From when should we actually check messages?" }, { name: "invert", description: "Inverts the logic, checking if a message is not received." }] },
            4: { name: "RELAY", params: [{ name: "relay", description: "The target relay to send this request too. You will likely always want to use the placeholder name that was created as part of REZ or ATTACH." }, { name: "channel", description: "On what channel should the relay send a message? If using a placeholder must resolve to a integer." }, { name: "message", description: "What is the message to send? You can use multiple placeholders to format your message." }, { name: "channelType", description: "What kind of communication should the relay use?" }] },
            5: { name: "ATTACH", params: [{ name: "name", description: "The name to give the rezzed dummy. Can use multiple placeholders if you so wish." }] },
            6: { name: "ASSERT", params: [{ name: "channel", description: "What channel should be monitored. If using a placeholder must resolve to a integer." }, { name: "waitTime", description: "How long, in milliseconds, should we collect messages for before sending this off to the PH script?" }, { name: "type", description: "From when should we actually check messages?" }] },
            7: { name: "EXPECTRLV", params: [{ name: "restriction", description: "The RLV restriction to check for." }, { name: "value", description: "What value should this RLV restriction be, this value can be empty (and will not trigger the empty-value warning).", optional: true }, { name: "invert", description: "Inverts the logic, checking if a restriction is not present or if a value is provided checks if the value is not the same." }] },
            8: { name: "WAIT", params: [{ name: "waitTime", description: "How long should the tester wait before moving to the next task?" }] }
        };

        const TYPE_HELP = "<ul><li><b>SEND</b>: Send a message on a channel to kick off the test</li><li><b>ASK</b>: Ask a Yes/No question, if answered with No then the test is marked as failed.</li><li><b>REZ</b>: Rezzes a Relay object. It's name gets added to LSD as a placeholder with the value being its UUID.</li><li><b>EXPECT</b>: Assert a certain value is returned since beginning of test, SEND or RELAY. If a * is added any remaining string after the * is ignored.</li><li><b>RELAY</b>: Instructs a given Relay object to relay a message.</li><li><b>ATTACH</b>: Attaches a Relay object. It's name gets added to LSD as a placeholder with the value being its UUID.</li><li><b>ASSERT</b>: Sends a message that is meant to be received by the testsuite_PH.lsl script. It can then do any kind of custom parsing and comparison it wants.</li><li><b>EXPECTRLV</b>: Checks for the presence of an RLV restriction and compares it to the value provided.</li><li><b>WAIT</b>: A simple wait task, useful when your API needs to gather data before the next task.</li></ul>";
        const ACTION_HELP = "Almost all parameters support placeholders. You define those yourself with the testsuite_PH.lsl script, or they are added via some actions. In all cases you can refer to a placeholder using the '$' token, for example: $AV. Four placeholders are added by default:<ul><li><b>AV</b>: Holds the owner avatar's UUID</li><li><b>TESTCHANNEL</b>: Holds the integer for the test channel</li><li><b>THIS</b>: Holds the UUID of the tester</li><li><b>NULL</b>: Holds the UUID that is NULL_KEY</li></ul>";

        const EXPECT_TYPES = ["Beginning of test", "Since last SEND", "Since last RELAY"];
        const RELAY_CHANNELS = ["RegionSayTo", "llSay", "llWhisper", "llShout"];
        const BOOLEAN_TYPES = ["False", "True"];

        const DEFAULT_COMMONACTIONS = [{ "REZ_DUMMY": { "name": "Rez dummy", "actionType": 2, "parameters": ["DUMMY", 2.5] } }, { "ATTACH_DUMMY": { "name": "Attach dummy", "actionType": 5, "parameters": ["ATTACH"] } }];

        const RLV_RESTRICTIONS = [
            { description: "--- MOVEMENT & BASICS ---" },
            { restriction: "fly", description: "Flight" },
            { restriction: "jump", description: "Jumping" },
            { restriction: "sit", description: "Sitting down" },
            { restriction: "stand", description: "Standing up" },
            { restriction: "walk", description: "Walking" },
            { restriction: "run", description: "Running" },
            { restriction: "temprun", description: "Double-tap running" },
            { restriction: "alwaysrun", description: "Always-run toggle (Ctrl-R)" },
            { restriction: "flee", description: "Fleeing (RLVa)" },

            { description: "--- TELEPORTATION ---" },
            { restriction: "tploc", description: "Location Teleport (Map/Beacons)" },
            { restriction: "tplure", description: "Teleport Requests (Lures)" },
            { restriction: "tplm", description: "Landmark Teleport" },
            { restriction: "sittp", description: "Teleport-by-sit" },
            { restriction: "standtp", description: "Teleport-by-standup" },
            { restriction: "tpworldmap", description: "Teleport via World Map" },
            { restriction: "tpminimap", description: "Teleport via Mini-Map" },
            { restriction: "tplocal", description: "Local TP Range (RLVa)" },

            { description: "--- COMMUNICATION (BINARY) ---" },
            { restriction: "sendchat", description: "Public Chat sending" },
            { restriction: "recvchat", description: "Public Chat receiving" },
            { restriction: "sendim", description: "IM sending" },
            { restriction: "recvim", description: "IM receiving" },
            { restriction: "startim", description: "Starting new IM sessions" },
            { restriction: "sendchannel", description: "Non-public channel chat" },
            { restriction: "voice", description: "Voice Chat" },
            { restriction: "emote", description: "Emoting (/me)" },

            { description: "--- COMMUNICATION (DYNAMIC/RLVa) ---" },
            { restriction: "recvchatfrom", description: "Receive chat from specific UUID" },
            { restriction: "sendimto", description: "Send IM to specific UUID" },
            { restriction: "recvimfrom", description: "Receive IM from specific UUID" },
            { restriction: "sendim_dist", description: "IM Sending Distance (RLVa)" },
            { restriction: "recvim_dist", description: "IM Receiving Distance (RLVa)" },

            { description: "--- INVENTORY & ATTACHMENTS ---" },
            { restriction: "detach", description: "Detaching objects" },
            { restriction: "attach", description: "Attaching new objects" },
            { restriction: "wear", description: "Changing clothes/outfits" },
            { restriction: "addoutfit", description: "Adding to current outfit" },
            { restriction: "remoutfit", description: "Removing from current outfit" },
            { restriction: "rez", description: "Rezzing/dropping items" },
            { restriction: "sharedwear", description: "Adding to #RLV folder (RLVa)" },
            { restriction: "unsharedwear", description: "Removing from #RLV folder (RLVa)" },

            { description: "--- INTERACTION & WORLD ---" },
            { restriction: "edit", description: "Editing any object" },
            { restriction: "interact", description: "World Interaction (RLVa)" },
            { restriction: "fartouch", description: "Touch distance limit (RLVa)" },
            { restriction: "temptouch", description: "Touching objects (Standard)" },
            { restriction: "touchhud", description: "Clicking HUDs (RLVa)" },
            { restriction: "touchworld", description: "Clicking In-World objects (RLVa)" },
            { restriction: "editobj", description: "Editing specific UUID" },

            { description: "--- UI VISIBILITY ---" },
            { restriction: "showinv", description: "Inventory window" },
            { restriction: "showloc", description: "Location/Coordinates UI" },
            { restriction: "showworldmap", description: "World Map window" },
            { restriction: "showminimap", description: "Mini-map window" },
            { restriction: "shownames", description: "Avatar Names/Hovertext" },
            { restriction: "shownametags", description: "Avatar Nametags (RLVa)" },
            { restriction: "shownearby", description: "Nearby Radar/People (RLVa)" },
            { restriction: "showsocial", description: "Friends/Groups lists" },
            { restriction: "showappearance", description: "Appearance Editor" },
            { restriction: "showhovertextall", description: "All Hovertext (RLVa)" },
            { restriction: "showtopmenu", description: "Viewer Top Menu (RLVa)" },

            { description: "--- VISION & CAMERA ---" },
            { restriction: "camunlock", description: "Camera movement (Free Cam)" },
            { restriction: "camtextures", description: "World Textures (RLV)" },
            { restriction: "setcam_textures", description: "World Textures (RLVa)" },
            { restriction: "setoverlay", description: "Full-screen Texture Overlay" },
            { restriction: "setsphere", description: "Vision Sphere/Shader" },
            { restriction: "setcam_fovmin", description: "Min Field of View" },
            { restriction: "setcam_fovmax", description: "Max Field of View" },
            { restriction: "showself", description: "Own avatar body (RLVa)" },
            { restriction: "showselfhead", description: "Own head/First-person (RLVa)" },
            { restriction: "mouselook", description: "Force/Block Mouselook" },

            { description: "--- SYSTEM & MISC ---" },
            { restriction: "setgroup", description: "Changing active group" },
            { restriction: "setenv", description: "Changing Windlight/Environment" },
            { restriction: "permissive", description: "Permissive Mode" },
            { restriction: "notify", description: "System Notifications" },
            { restriction: "search", description: "Search Window" },
            { restriction: "gesture", description: "Using Gestures" },
            { restriction: "outfit", description: "Outfit Gallery" },
            { restriction: "logshow", description: "Chat/IM History (RLVa)" }
        ];

        // Fields that should be numbers if possible, but strings if they are placeholders ($)
        const NUMERIC_FIELDS = ["channel", "distance", "time", "waitTime"];

        const INITIAL_JSON = {
            $schema: "https://raw.githubusercontent.com/Nensec/lsl-api-tester/refs/heads/master/test-suite.schema.json",
            name: "New Suite",
            version: "v1.0",
            tests: [],
            commonActions: []
        };

        // -- HELPER COMPONENTS

        // A smart input that handles the Number vs Placeholder string logic
        const SmartInput = ({ value, onChange, placeholder, type = "text" }) => {
            const [localValue, setLocalValue] = useState(value);

            useEffect(() => { setLocalValue(value); }, [value]);

            const handleBlur = () => {
                if (localValue === "" || localValue === null || localValue === undefined) {
                    onChange("");
                    return;
                }
                // If it looks like a number, save as number. Otherwise string.
                const asNum = Number(localValue);
                if (!isNaN(asNum) && localValue.toString().trim() !== "") {
                    onChange(asNum);
                } else {
                    onChange(localValue);
                }
            };

            return (
                <input
                    type={type}
                    className="form-control form-control"
                    value={localValue || ""}
                    onChange={(e) => setLocalValue(e.target.value)}
                    onBlur={handleBlur}
                    placeholder={placeholder}
                />
            );
        };

        // -- MAIN APP COMPONENT

        function App() {
            const [data, setData] = useState(INITIAL_JSON);
            const [view, setView] = useState("dashboard"); // dashboard, test, common
            const [selectedId, setSelectedId] = useState(null); // The Key of the selected item

            const [modalJson, setModalJson] = useState("");

            // Formats JSON text with HTML span classes for CSS targeting
            const syntaxHighlight = (json) => {
                if (typeof json != 'string') json = JSON.stringify(json, undefined, 2);
                json = json.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                return json.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, function (match) {
                    let cls = 'json-number';
                    if (/^"/.test(match)) {
                        if (/:$/.test(match)) cls = 'json-key';
                        else cls = 'json-string';
                    } else if (/true|false/.test(match)) {
                        cls = 'json-boolean';
                    } else if (/null/.test(match)) {
                        cls = 'json-null';
                    }
                    return '<span class="' + cls + '">' + match + '</span>';
                });
            };

            // Checks for empty parameters and sanitizes nulls/missing fields
            const sanitizeAndValidate = () => {
                let hasEmpty = false;
                let newData = JSON.parse(JSON.stringify(data)); // Deep copy

                const checkActions = (actions) => {
                    actions.forEach(action => {
                        if (typeof action === 'object') {
                            const actionDef = ACTION_TYPES[action.actionType] || ACTION_TYPES[0];
                            const expectedParams = actionDef.params.length;

                            action.parameters = action.parameters.slice(0, expectedParams);

                            for (let i = 0; i < expectedParams; i++) {
                                // If a parameter is optional then skip and go to the next parameter                            
                                if (actionDef.params[i].optional)
                                    continue;

                                const pName = actionDef.params[i].name;
                                const isEnum = pName === "type" || pName === "channelType" || pName === "invert";

                                // Check if the value is missing or completely empty
                                if (action.parameters[i] === null || action.parameters[i] === undefined || action.parameters[i] === "") {
                                    if (isEnum) {
                                        // Automatically fix missing enumerated fields to 0 without warning
                                        action.parameters[i] = 0;
                                    } else {
                                        // It's a normal string/number field, force clean string and flag warning
                                        action.parameters[i] = "";
                                        hasEmpty = true;
                                    }
                                }
                            }
                        }
                    });
                };

                newData.tests.forEach(t => {
                    const testKey = Object.keys(t)[0];
                    const testObj = t[testKey];

                    if (testObj.dependencies && testObj.dependencies.length === 0) {
                        delete testObj.dependencies;
                    }

                    checkActions(testObj.actions);
                });



                if (newData.commonActions) {
                    if (newData.commonActions.length === 0) {
                        delete newData.commonActions;
                    } else {
                        newData.commonActions.forEach(c => checkActions([c[Object.keys(c)[0]]]));
                    }
                }

                return { safeData: newData, hasEmpty };
            };

            // -- DATA ACCESSORS
            // The schema uses [{ "Key": { val } }], which is annoying to map. We convert to array of objects with keys for UI.

            const getTests = () => (data.tests || []).map(t => {
                const key = Object.keys(t)[0];
                return { key, ...t[key] };
            });

            const getCommonActions = () => (data.commonActions || []).map(c => {
                const key = Object.keys(c)[0];
                return { key, ...c[key] };
            });

            // -- MANIPULATORS

            const handleFileUpload = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const json = JSON.parse(event.target.result);
                        // Force clean state override
                        setData({
                            $schema: "https://raw.githubusercontent.com/Nensec/lsl-api-tester/refs/heads/master/test-suite.schema.json",
                            name: json.name || "New Suite",
                            version: json.version || "v1.0",
                            tests: json.tests || [],
                            commonActions: json.commonActions || []
                        });
                        setView("dashboard");
                        setSelectedId(null);
                    } catch (err) {
                        alert("Error parsing JSON file.");
                    }
                };
                reader.readAsText(file);
                e.target.value = null; // Reset input so same file can be uploaded again
            };

            const handleExport = (type) => { // 'download' or 'view'
                const { safeData, hasEmpty } = sanitizeAndValidate();

                if (hasEmpty) {
                    if (!confirm("Warning: One or more action parameters are completely empty.\n\nIf you proceed, they will be saved as empty strings (\"\"). Do you want to continue?")) return;
                }

                // Save the sanitized data back to state so UI reflects the cleaned nulls
                setData(safeData);

                const jsonStr = JSON.stringify(safeData, null, 2);

                if (type === 'download') {
                    const blob = new Blob([jsonStr], { type: "application/json" });
                    const a = document.createElement("a");
                    a.href = URL.createObjectURL(blob);
                    a.download = `${safeData.name.replace(/\s+/g, '_')}_${safeData.version}.txt`;
                    a.click();
                } else {
                    setModalJson(jsonStr);
                    const modal = new bootstrap.Modal(document.getElementById('jsonModal'));
                    modal.show();
                }
            };

            const clearAll = () => {
                if (confirm("Clear everything? Unsaved changes will be lost, make sure you download your JSON first!")) {
                    setData(INITIAL_JSON);
                    setView("dashboard");
                }
            };

            const addTest = () => {
                const name = prompt("Enter Test Name:");
                if (!name) return;
                if (getTests().find(t => t.key === name)) return alert("Name already exists");

                const newTest = { [name]: { dependencies: [], actions: [] } };
                setData(prev => ({ ...prev, tests: [...prev.tests, newTest] }));
                setSelectedId(name);
                setView("test");
            };

            const moveTest = (direction) => {
                if (view !== 'test' || !selectedId) return;

                // Find the index of the currently selected test
                const index = data.tests.findIndex(t => Object.keys(t)[0] === selectedId);
                if (index === -1) return;

                const newTests = [...data.tests];

                // Swap logic
                if (direction === -1 && index > 0) {
                    // Move Up
                    [newTests[index], newTests[index - 1]] = [newTests[index - 1], newTests[index]];
                } else if (direction === 1 && index < newTests.length - 1) {
                    // Move Down
                    [newTests[index], newTests[index + 1]] = [newTests[index + 1], newTests[index]];
                }

                setData({ ...data, tests: newTests });
            };

            const addCommonAction = () => {
                const name = prompt("Enter Common Action Name (ID):");
                if (!name) return;
                if (getCommonActions().find(c => c.key === name)) return alert("Name already exists");

                // Default Action Structure
                const newAction = { [name]: { name: "New Action", actionType: 0, parameters: Array(ACTION_TYPES[0].params.length).fill("") } };
                setData(prev => ({ ...prev, commonActions: [...prev.commonActions, newAction] }));
                setSelectedId(name);
                setView("common");
            };

            const deleteTest = (key) => {
                // Check dependencies
                const dependants = getTests().filter(t => t.dependencies && t.dependencies.includes(key));
                if (dependants.length > 0) {
                    const names = dependants.map(t => t.key).join(", ");
                    if (!confirm(`Warning: The following tests depend on this test:\n${names}\n\nDeleting this will remove the dependency from them. Continue?`)) {
                        return;
                    }
                    // Clean up dependencies in other tests
                    const cleanedTests = data.tests.filter(t => Object.keys(t)[0] !== key).map(t => {
                        const k = Object.keys(t)[0];
                        const obj = t[k];
                        if (obj.dependencies.includes(key)) {
                            return { [k]: { ...obj, dependencies: obj.dependencies.filter(d => d !== key) } };
                        }
                        return t;
                    });
                    setData({ ...data, tests: cleanedTests });
                } else {
                    if (!confirm("Are you sure you want to delete this test?")) return;
                    setData({ ...data, tests: data.tests.filter(t => Object.keys(t)[0] !== key) });
                }
                setView("dashboard");
            };

            const deleteCommonAction = (key) => {
                if (!confirm("Are you sure? This might break tests referencing this action.")) return;
                setData({ ...data, commonActions: (data.commonActions || []).filter(c => Object.keys(c)[0] !== key) });
                setView("dashboard");
            };

            const renameKey = (oldKey, newKey, type) => {
                if (oldKey === newKey) return;

                if (type === "test") {
                    // Check exist
                    if (getTests().find(t => t.key === newKey)) return alert("Name exists");

                    // Update Key
                    const newTests = (data.tests || []).map(t => {
                        const k = Object.keys(t)[0];
                        if (k === oldKey) return { [newKey]: t[k] };

                        // Update dependencies in other tests
                        if (t[k].dependencies.includes(oldKey)) {
                            const newDeps = t[k].dependencies.map(d => d === oldKey ? newKey : d);
                            return { [k]: { ...t[k], dependencies: newDeps } };
                        }
                        return t;
                    });
                    setData({ ...data, tests: newTests });
                    setSelectedId(newKey);
                } else {
                    // Common Action Rename
                    if (getCommonActions().find(c => c.key === newKey)) return alert("Name exists");

                    // Update Definition
                    const newCA = (data.commonActions || []).map(c => {
                        const k = Object.keys(c)[0];
                        return k === oldKey ? { [newKey]: c[k] } : c;
                    });

                    // Update References in ALL Tests
                    const newTests = (data.tests || []).map(t => {
                        const k = Object.keys(t)[0];
                        const newActions = t[k].actions.map(a => (typeof a === 'string' && a === oldKey) ? newKey : a);
                        return { [k]: { ...t[k], actions: newActions } };
                    });

                    setData({ ...data, commonActions: newCA, tests: newTests });
                    setSelectedId(newKey);
                }
            };

            // -- RENDERERS

            useEffect(() => {
                // Initialize all tooltips on the page
                const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle="tooltip"]');
                const tooltipList = [...tooltipTriggerList].map(el => new bootstrap.Tooltip(el));

                // Cleanup tooltips when component unmounts or updates
                return () => {
                    tooltipList.forEach(t => t.dispose());
                };
            }, [view, selectedId, data]); // Re-run when navigation or data changes

            return (
                <div className="container-fluid">
                    <div className="row">
                        {/* SIDEBAR */}
                        <div className="col-md-3 sidebar p-3">
                            <h4 className="mb-3">V's Tester | Test Builder</h4>
                            <p>Note: Because I quite frankly suck at front-end development, this GUI has been created largely using Google Gemini. Whilst I understand largely what it does, I am not a react developer or do much in javascript. Bugs can happen, though it all <i>seems</i> to work..?</p>
                            <p>Maybe one day I will re-build it from scratch without LLM handholding, but this allows me to focus on actually working on other projects rather than getting stuck on a GUI ðŸ˜”</p>
                            <div className="row">
                                <div className="col-8">
                                    <label className="form-label fw-bold">Suite Name</label>
                                    <input className="form-control" value={data.name} onChange={e => setData({ ...data, name: e.target.value })} />
                                </div>
                                <div className="col-4">
                                    <label className="form-label fw-bold">Version</label>
                                    <input className="form-control" value={data.version} onChange={e => setData({ ...data, version: e.target.value })} />
                                </div>
                            </div>

                            <hr />

                            <div className="border rounded-2 p-3 mb-3">
                                <div className="d-flex justify-content-between align-items-center mb-2">
                                    <h5 className="m-0">Tests</h5>
                                    <div>
                                        <div className="btn-group">
                                            <button
                                                className="btn btn-xs btn-secondary"
                                                onClick={() => moveTest(-1)}
                                                disabled={view !== 'test' || !selectedId}
                                                data-bs-toggle="tooltip" data-bs-placement="top" data-bs-title="Move selected test up"
                                            >
                                                â–²
                                            </button>
                                            <button
                                                className="btn btn-xs btn-secondary"
                                                onClick={() => moveTest(1)}
                                                disabled={view !== 'test' || !selectedId}
                                                data-bs-toggle="tooltip" data-bs-placement="top" data-bs-title="Move selected test down"
                                            >
                                                â–¼
                                            </button>
                                        </div>
                                        <button className="btn btn-xs btn-primary ms-2" onClick={addTest} data-bs-toggle="tooltip" data-bs-placement="top" data-bs-title="Add new test">+</button>
                                    </div>
                                </div>
                                <div className="list-group">
                                    {getTests().map(t => (
                                        <button key={t.key}
                                            className={`list-group-item list-group-item-action ${view === 'test' && selectedId === t.key ? 'active' : ''}`}
                                            onClick={() => { setView('test'); setSelectedId(t.key); }}
                                        >
                                            {t.key}
                                        </button>
                                    ))}
                                </div>
                            </div>
                            <div className="border rounded-2 p-3">
                                <div className="d-flex justify-content-between align-items-center mb-2">
                                    <h5 className="m-0">Common Actions</h5>
                                    <button className="btn btn-sm btn-success" onClick={addCommonAction} data-bs-toggle="tooltip" data-bs-placement="top" data-bs-title="Add new common action">+</button>
                                </div>
                                <div className="list-group">
                                    {getCommonActions().map(c => (
                                        <button key={c.key}
                                            className={`list-group-item list-group-item-action ${view === 'common' && selectedId === c.key ? 'active' : ''}`}
                                            onClick={() => { setView('common'); setSelectedId(c.key); }}
                                        >
                                            {c.key}
                                        </button>
                                    ))}
                                </div>
                            </div>

                            <hr />
                            <div className="d-grid">
                                <label className="btn btn-secondary btn-sm my-2">
                                    Upload JSON <input type="file" hidden accept=".json,.txt" onChange={handleFileUpload} />
                                </label>
                                <div className="btn-group">
                                    <button className="btn btn-primary btn-sm w-50" onClick={() => handleExport('view')}>View JSON</button>
                                    <button className="btn btn-success btn-sm w-50" onClick={() => handleExport('download')}>Download JSON</button>
                                </div>
                                <button className="btn btn-danger btn-sm my-2" onClick={clearAll}>Clear All</button>
                            </div>
                        </div>

                        {/* MAIN CONTENT */}
                        <div className="col-md-9 main-content">
                            {view === 'dashboard' && (
                                <div className="alert alert-info">Select a Test or Common Action to edit.</div>
                            )}

                            {view === 'test' && selectedId && (
                                <TestEditor
                                    testKey={selectedId}
                                    data={data}
                                    setData={setData}
                                    onRename={(newKey) => renameKey(selectedId, newKey, 'test')}
                                    onDelete={() => deleteTest(selectedId)}
                                />
                            )}

                            {view === 'common' && selectedId && (
                                <CommonActionWrapper
                                    actionKey={selectedId}
                                    data={data}
                                    setData={setData}
                                    onRename={(newKey) => renameKey(selectedId, newKey, 'common')}
                                    onDelete={() => deleteCommonAction(selectedId)}
                                />
                            )}
                        </div>
                    </div>
                    {/* JSON VIEWER MODAL */}
                    <div className="modal fade" id="jsonModal" tabIndex="-1" aria-hidden="true">
                        <div className="modal-dialog modal-lg modal-dialog-centered modal-dialog-scrollable">
                            <div className="modal-content bg-dark text-light border-secondary">
                                <div className="modal-header border-secondary">
                                    <h5 className="modal-title">JSON Viewer</h5>
                                    <button type="button" className="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                                </div>
                                <div className="modal-body p-0">
                                    <pre className="json-container m-0" dangerouslySetInnerHTML={{ __html: syntaxHighlight(modalJson) }}></pre>
                                </div>
                                <div className="modal-footer border-secondary">
                                    <button type="button" className="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                                    <button type="button" className="btn btn-primary" onClick={() => {
                                        navigator.clipboard.writeText(modalJson);
                                        alert("JSON copied to clipboard!");
                                    }}>Copy to Clipboard</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        // -- TEST EDITOR

        function TestEditor({ testKey, data, setData, onRename, onDelete }) {
            // Extract current test data
            const testObj = (data.tests || []).find(t => Object.keys(t)[0] === testKey)[testKey];
            const allTestKeys = (data.tests || []).map(t => Object.keys(t)[0]);
            const commonActionKeys = Array.prototype.concat(DEFAULT_COMMONACTIONS, data.commonActions || []).map(c => Object.keys(c)[0]);
            const [localName, setLocalName] = useState(testKey);

            useEffect(() => {
                setLocalName(testKey);
            }, [testKey]);

            const updateTest = (newData) => {
                const newTests = (data.tests || []).map(t => {
                    const k = Object.keys(t)[0];
                    return k === testKey ? { [k]: newData } : t;
                });
                setData({ ...data, tests: newTests });
            };

            const toggleDependency = (depKey) => {
                const currentDeps = testObj.dependencies || [];
                if (currentDeps.includes(depKey)) {
                    updateTest({ ...testObj, dependencies: currentDeps.filter(d => d !== depKey) });
                } else {
                    updateTest({ ...testObj, dependencies: [...currentDeps, depKey] });
                }
            };

            const addAction = (type) => { // type = 'custom' or 'common'
                let newAction;
                if (type === 'custom') {
                    newAction = { name: "New Action", actionType: 0, parameters: Array(ACTION_TYPES[0].params.length).fill("") };
                } else {
                    if (commonActionKeys.length === 0) return alert("No common actions defined");
                    newAction = commonActionKeys[0]; // Default to first
                }
                updateTest({ ...testObj, actions: [...(testObj.actions || []), newAction] });
            };

            const updateAction = (index, newVal) => {
                const newActions = [...testObj.actions];
                newActions[index] = newVal;
                updateTest({ ...testObj, actions: newActions });
            };

            const removeAction = (index) => {
                const newActions = testObj.actions.filter((_, i) => i !== index);
                updateTest({ ...testObj, actions: newActions });
            };

            const moveAction = (index, dir) => {
                const newActions = [...testObj.actions];
                if (dir === -1 && index > 0) {
                    [newActions[index], newActions[index - 1]] = [newActions[index - 1], newActions[index]];
                } else if (dir === 1 && index < newActions.length - 1) {
                    [newActions[index], newActions[index + 1]] = [newActions[index + 1], newActions[index]];
                }
                updateTest({ ...testObj, actions: newActions });
            };

            return (
                <div>
                    <div className="d-flex justify-content-between border-bottom pb-3 mb-3">
                        <div className="d-flex gap-2 align-items-center">
                            <h3 className="m-0">Test:</h3>
                            <input className="form-control"
                                value={localName}
                                onChange={(e) => setLocalName(e.target.value)} // Updates the box as you type
                                onBlur={(e) => onRename(e.target.value)}
                            />
                        </div>
                        <button className="btn btn-danger" onClick={onDelete}>Delete Test</button>
                    </div>

                    <div className="row mb-4">
                        <div className="col-12">
                            <label className="fw-bold">Dependencies</label>
                            <div className="card p-2 mt-2" style={{ maxHeight: '150px', overflowY: 'auto' }}>
                                {allTestKeys.filter(k => k !== testKey).map(k => (
                                    <div key={k} className="form-check">
                                        <input className="form-check-input" type="checkbox"
                                            checked={(testObj.dependencies || []).includes(k)}
                                            onChange={() => toggleDependency(k)}
                                        />
                                        <label className="form-check-label">{k}</label>
                                    </div>
                                ))}
                                {allTestKeys.length <= 1 && <em className="text-muted">No other tests available</em>}
                            </div>
                        </div>
                    </div>

                    <div className="mb-3 d-flex justify-content-between align-items-center">
                        <h4>Actions Sequence</h4>
                        <div className="btn-group">
                            <button className="btn btn-primary btn-sm" onClick={() => addAction('custom')}>+ Custom Action</button>
                            <button className="btn btn-success btn-sm" onClick={() => addAction('common')}>+ Common Action</button>
                        </div>
                    </div>

                    <div>
                        {testObj.actions && testObj.actions.map((action, idx) => (
                            <div key={idx} className="d-flex gap-2 align-items-start mb-2">
                                <div className="d-flex flex-column gap-1 pt-2">
                                    <button className="btn btn-xs btn-dark border" onClick={() => moveAction(idx, -1)}>â–²</button>
                                    <button className="btn btn-xs btn-dark border" onClick={() => moveAction(idx, 1)}>â–¼</button>
                                </div>

                                <div className="flex-grow-1">
                                    {typeof action === 'string' ? (
                                        <div className="card action-card common-ref p-3">
                                            <div className="d-flex justify-content-between align-items-center">
                                                <div>
                                                    <strong>Common Action Reference:</strong>
                                                    <select className="form-select d-inline-block w-auto ms-2"
                                                        value={action}
                                                        onChange={(e) => updateAction(idx, e.target.value)}
                                                    >
                                                        {commonActionKeys.map(k => <option key={k} value={k}>{k}</option>)}
                                                    </select>
                                                </div>
                                                <button className="btn btn-danger" onClick={() => removeAction(idx)}>Remove</button>
                                            </div>
                                        </div>
                                    ) : (
                                        <ActionEditor
                                            action={action}
                                            onChange={(newVal) => updateAction(idx, newVal)}
                                            onRemove={() => removeAction(idx)}
                                        />
                                    )}
                                </div>
                            </div>
                        ))}
                        {(!testObj.actions || testObj.actions.length === 0) && <p className="text-muted text-center">No actions added yet.</p>}
                    </div>
                </div>
            );
        }

        // -- COMMON ACTION EDITOR WRAPPER
        // Wraps the inner ActionEditor to handle the top-level object structure of Common Actions

        function CommonActionWrapper({ actionKey, data, setData, onRename, onDelete }) {
            const actionObj = (data.commonActions || []).find(c => Object.keys(c)[0] === actionKey)[actionKey];
            const [localName, setLocalName] = useState(actionKey);

            useEffect(() => {
                setLocalName(actionKey);
            }, [actionKey]);

            const handleChange = (newVal) => {
                const newArr = (data.commonActions || []).map(c => {
                    const k = Object.keys(c)[0];
                    return k === actionKey ? { [k]: newVal } : c;
                });
                setData({ ...data, commonActions: newArr });
            };

            return (
                <div>
                    <div className="d-flex justify-content-between border-bottom pb-3 mb-3">
                        <div className="d-flex gap-2 align-items-center">
                            <h3 className="m-0 text-nowrap">Common Action:</h3>
                            <input className="form-control"
                                value={localName}
                                onChange={(e) => setLocalName(e.target.value)}
                                onBlur={(e) => onRename(e.target.value)}
                            />
                        </div>
                        <button className="btn btn-danger" onClick={onDelete}>Delete</button>
                    </div>
                    <ActionEditor action={actionObj} onChange={handleChange} isCommonRef={true} />
                </div>
            );
        }

        // -- GENERIC ACTION EDITOR
        // Renders inputs based on Action Type

        function ActionEditor({ action, onChange, onRemove, isCommonRef = false }) {

            const typeDef = ACTION_TYPES[action.actionType] || ACTION_TYPES[0];

            const updateField = (field, val) => {
                // If changing type, reset params to match the count
                if (field === 'actionType') {
                    val = parseInt(val);
                    const newTypeDef = ACTION_TYPES[val];
                    // Resize parameters array, preserving what fits, filling empty strings
                    const newParams = newTypeDef.params.map(p => {
                        if (p.name === "type" || p.name === "channelType" || p.name == "invert") {
                            return 0;
                        }
                        return "";
                    });
                    onChange({ ...action, actionType: val, parameters: newParams });
                } else if (field === 'name') {
                    onChange({ ...action, name: val });
                }
            };

            const updateParam = (idx, val) => {
                const newParams = [...action.parameters];
                newParams[idx] = val;
                onChange({ ...action, parameters: newParams });
            };

            const renderParamInput = (paramName, idx) => {
                // Logic for specific parameter names

                // "type" parameter (EXPECT/ASSERT)
                if (paramName === "type") {
                    return (
                        <select className="form-select" value={(action.parameters[idx] === "" || action.parameters[idx] === undefined) ? 0 : action.parameters[idx]} onChange={e => updateParam(idx, parseInt(e.target.value))}>
                            {EXPECT_TYPES.map((t, i) => <option key={i} value={i}>{i} - {t}</option>)}
                        </select>
                    );
                }

                // "channelType" parameter (RELAY)
                if (paramName === "channelType") {
                    return (
                        <select className="form-select" value={(action.parameters[idx] === "" || action.parameters[idx] === undefined) ? 0 : action.parameters[idx]} onChange={e => updateParam(idx, parseInt(e.target.value))}>
                            {RELAY_CHANNELS.map((t, i) => <option key={i} value={i}>{i} - {t}</option>)}
                        </select>
                    );
                }

                // "invert" parameter (EXPECT)
                if (paramName === "invert") {
                    return (
                        <select className="form-select" value={(action.parameters[idx] === "" || action.parameters[idx] === undefined) ? 0 : action.parameters[idx]} onChange={e => updateParam(idx, parseInt(e.target.value))}>
                            {BOOLEAN_TYPES.map((t, i) => <option key={i} value={i}>{i} - {t}</option>)}
                        </select>
                    );
                }

                // "restriction" parameter (EXPECTRLV)
                if (paramName === "restriction") {
                    return (
                        <select className="form-select" value={(action.parameters[idx] === "" || action.parameters[idx] === undefined) ? "" : action.parameters[idx]} onChange={e => updateParam(idx, e.target.value)}>
                            <option disabled value="">Choose restriction</option>
                            {RLV_RESTRICTIONS.map((t, i) => <option key={i} value={t.restriction ? t.restriction : ""} disabled={t.restriction ? false : true}>{t.restriction ? t.restriction + " - " : ""}{t.description}</option>)}
                        </select>
                    );
                }

                // Numeric fields that allow String Placeholders ($)
                if (NUMERIC_FIELDS.includes(paramName)) {
                    return <SmartInput value={action.parameters[idx]} onChange={val => updateParam(idx, val)} placeholder={paramName} />;
                }

                // Standard Text
                return <input type="text" className="form-control" value={action.parameters[idx]} onChange={e => updateParam(idx, e.target.value)} placeholder={paramName} />;
            };

            return (
                <div className={`card action-card p-3 ${isCommonRef ? 'common-ref' : ''}`}>
                    <div className="row bg-dark p-2 pb-3 m-0 rounded border">
                        <div className="col-md-4">
                            <label className="form-label small fw-bold text-uppercase">Action Name</label>
                            <input type="text" className="form-control" value={action.name} onChange={e => updateField('name', e.target.value)} />
                        </div>
                        <div className="col-md-4">
                            <label className="form-label small fw-bold text-uppercase">Type <span className="ms-1 infoBubble" data-bs-toggle="tooltip" data-bs-placement="top" data-bs-html="true" data-bs-title={TYPE_HELP} style={{ cursor: 'help' }}>â„¹ï¸</span></label>
                            <select className="form-select" value={action.actionType} onChange={e => updateField('actionType', e.target.value)}>
                                {Object.entries(ACTION_TYPES).map(([k, v]) => (
                                    <option key={k} value={k}>{k} - {v.name}</option>
                                ))}
                            </select>
                        </div>
                        <div className="align-items-center col-md-4 d-flex justify-content-end">
                            <p><span className="px-2 infoBubble infoBubbleLarge" data-bs-toggle="tooltip" data-bs-placement="top" data-bs-title={ACTION_HELP} data-bs-html="true" style={{ cursor: 'help' }}>â„¹ï¸</span></p>
                            {!isCommonRef && (
                                <button className="btn btn-danger" onClick={onRemove}>Remove</button>
                            )}
                        </div>
                        <hr className="my-3" />
                        <div className="col-12">
                            <div className="row">
                                {typeDef.params.map((p, i) => (
                                    <div className="col" key={i}>
                                        <label className="form-label small fw-bold text-uppercase">{p.name} <span className="ms-1 infoBubble" data-bs-toggle="tooltip" data-bs-placement="top" data-bs-title={p.description} style={{ cursor: 'help' }}>â„¹ï¸</span></label>
                                        {renderParamInput(p.name, i)}
                                    </div>
                                ))}
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);

    </script>
</body>

</html>